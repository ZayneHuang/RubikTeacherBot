<!DOCTYPE html>
<html>

	<head>
		<meta charset="utf-8">
		<title>Video Capture Example</title>
	</head>

	<body>
		<h2><font color="#000000">魔方识别</font></h2>
		<div>
            <div class="control">
                <button id="startAndStop" disabled>Start</button>
                <button id="reStart" disabled>Clear</button>
                <button id="done" disabled>Done</button> 
                <button id="test">Test</button>
                <p class="msgTip" id="tips"></p>
            </div>
			<textarea class="code" rows="10" cols="100" id="codeEditor" spellcheck="false" hidden>
			</textarea>
		</div>
		<p class="err" id="errorMessage"></p>
		<div>
			<table cellpadding="0" cellspacing="0" width="0" border="1">
				<tr border="black">
					<td>
						<video id="videoInput" width=320 height=240 hidden></video>
					</td>
					<td>
						<canvas id="recogInput" width=320 height=240></canvas>
                    </td>
                    <td>
						<canvas id="recogOutput" width=320 height=240></canvas>
                    </td>
                    <td>
						<canvas id="recogFaceLeft" width=240 height=240></canvas>
                    </td>
                    <td>
						<canvas id="recogFaceRight" width=240 height=240></canvas>
					</td>
                </tr>
                <tr>
					<td>
						<div class="caption" hidden><font color="#000000">videoInput</font></div>
					</td>
					<td>
						<div class="caption"><font color="#000000">recogInput</font></div>
                    </td>
                    <td>
						<div class="caption"><font color="#000000">recogOutput</font></div>
                    </td>
                    <td>
                        <div class="caption"><font color="#000000">recogFaceLeft</font></div>
                    </td>
                    <td>
                        <div class="caption"><font color="#000000">recogFaceRight</font></div>
                    </td>
                </tr>
			</table>
        </div>
        <p class="msgL" id="showMsgL" hidden></p>
        <p class="msgR" id="showMsgR" hidden></p>
		<div>
            <table border="1" cellpadding="0" cellspacing="0" width="0">
                <tr height="30px">
                    <td rowspan="3" colspan="6" bgColor="#FFFFFF"></td>
                    <td width="30px" bgColor="gray" id="W0" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="W1" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="W2" onclick="blockChangeColor()"></td>
                    <td rowspan="3" colspan="3" bgColor="#FFFFFF"></td>
                </tr>
                <tr height="30px">
                    <td width="30px" bgColor="gray" id="W3" onclick="blockChangeColor()"></td><td width="30px" bgColor="#FFFFFF" id="W4"></td><td width="30px" bgColor="gray" id="W5" onclick="blockChangeColor()"></td>
                </tr>
                <tr height="30px">
                    <td width="30px" bgColor="gray" id="W6" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="W7" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="W8" onclick="blockChangeColor()"></td>
                </tr>
                <tr height="30px">
                    <td width="30px" bgColor="gray" id="B0" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="B1" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="B2" onclick="blockChangeColor()"></td>
                    <td width="30px" bgColor="gray" id="O0" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="O1" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="O2" onclick="blockChangeColor()"></td>
                    <td width="30px" bgColor="gray" id="G0" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="G1" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="G2" onclick="blockChangeColor()"></td>
                    <td width="30px" bgColor="gray" id="R0" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="R1" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="R2" onclick="blockChangeColor()"></td>
                </tr>
                <tr height="30px">
                    <td width="30px" bgColor="gray" id="B3" onclick="blockChangeColor()"></td><td width="30px" bgColor="#0000FF" id="B4"></td><td width="30px" bgColor="gray" id="B5" onclick="blockChangeColor()"></td>
                    <td width="30px" bgColor="gray" id="O3" onclick="blockChangeColor()"></td><td width="30px" bgColor="#FF8000" id="O4"></td><td width="30px" bgColor="gray" id="O5" onclick="blockChangeColor()"></td>
                    <td width="30px" bgColor="gray" id="G3" onclick="blockChangeColor()"></td><td width="30px" bgColor="#33CC33" id="G4"></td><td width="30px" bgColor="gray" id="G5" onclick="blockChangeColor()"></td>
                    <td width="30px" bgColor="gray" id="R3" onclick="blockChangeColor()"></td><td width="30px" bgColor="#E60000" id="R4"></td><td width="30px" bgColor="gray" id="R5" onclick="blockChangeColor()"></td>
                </tr>
                <tr height="30px">
                    <td width="30px" bgColor="gray" id="B6" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="B7" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="B8" onclick="blockChangeColor()"></td>
                    <td width="30px" bgColor="gray" id="O6" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="O7" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="O8" onclick="blockChangeColor()"></td>
                    <td width="30px" bgColor="gray" id="G6" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="G7" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="G8" onclick="blockChangeColor()"></td>
                    <td width="30px" bgColor="gray" id="R6" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="R7" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="R8" onclick="blockChangeColor()"></td>
                </tr>
                <tr height="30px">
                    <td rowspan="3" colspan="6" bgColor="#FFFFFF"></td>
                    <td width="30px" bgColor="gray" id="Y0" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="Y1" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="Y2" onclick="blockChangeColor()"></td>
                    <td rowspan="3" colspan="3" bgColor="#FFFFFF"></td>
                </tr>
                <tr height="30px">
                    <td width="30px" bgColor="gray" id="Y3" onclick="blockChangeColor()"></td><td width="30px" bgColor="#FFFF1A" id="Y4"></td><td width="30px" bgColor="gray" id="Y5" onclick="blockChangeColor()"></td>
                </tr>
                <tr height="30px">
                   <td width="30px" bgColor="gray" id="Y6" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="Y7" onclick="blockChangeColor()"></td><td width="30px" bgColor="gray" id="Y8" onclick="blockChangeColor()"></td>
                </tr>
            </table>
        </div>
    </body>
    <!--<script src="https://webrtc.github.io/adapter/adapter-5.0.4.js" type="text/javascript"></script>-->
    <script src="../static/utils.js" type="text/javascript"></script>
    <script id="codeSnippet" type="text/javascript">
        let video = document.getElementById('videoInput'); 
        let src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
        let recogInput = new cv.Mat(video.height, video.width, cv.CV_8UC4);
        let aftersplit = new cv.Mat(video.height, video.width, cv.CV_8UC4);
        // let contourSplit = new cv.Mat(video.height, video.width, cv.CV_8UC4);
        let faceLeft = new cv.Mat(video.height, video.height, cv.CV_8UC4);
        let dispLeft = new cv.Mat(video.height, video.height, cv.CV_8UC4);
        let faceRight = new cv.Mat(video.height, video.height, cv.CV_8UC4);
        let dispRight = new cv.Mat(video.height, video.height, cv.CV_8UC4);
        let dst = new cv.Mat(video.height, video.width, cv.CV_8UC4);
        let cap = new cv.VideoCapture(video);
        const FPS = 30;

        let xx = 160;
        let yy = 30;
        let side = 180;

        let dx = 100;
        let dyu = 15;
        let dyd = 20;

        let pointA = new cv.Point(xx-dx, yy+dyu);
        let pointB = new cv.Point(xx-dx, yy+side-dyd);
        let pointC = new cv.Point(xx, yy);
        let pointD = new cv.Point(xx, yy+side);
        let pointE = new cv.Point(xx+dx, yy+dyu);
        let pointF = new cv.Point(xx+dx, yy+side-dyd);

        let tips = document.getElementById('tips');

        function processVideo() { 
            try { 
                if (!streaming) { 
                    // clean and stop. 
                    src.delete(); 
                    dst.delete();
                    recogInput.delete();
                    aftersplit.delete();
                    faceLeft.delete();
                    dispLeft.delete();
                    faceRight.delete();
                    dispRight.delete();

                    tips.innerHTML = "";
                    
                    return;
                }
                // console.log(cube.cubestat);
                let begin = Date.now(); 
                // start processing. 
                cap.read(src);
                // cv.flip(src, dst, cv.ROTATE_180);
                drawPoly(src, recogInput);
                // cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
                // splitColor(src, aftersplit);
                // foreExtraction(src, dst)
                // grabCut(src, aftersplit);
                // cv.Canny(aftersplit, dst, 200, 100, 3, false);

                // let hierarchy = new cv.Mat();

                // let contours = new cv.MatVector();
                // cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                // for (let i=0; i<contours.size(); i++) {
                //     let color = new cv.Scalar(0, 0, 255);
                //     cv.drawContours(contourSplit, contours, i, color, 1, cv.LINE_8, hierarchy, 100);
                // }
                // cv.imshow("recogOutput", contourSplit);

                perspTransform(src, faceLeft, faceRight, dispLeft, dispRight);

                let colorLeft = recogColor(faceLeft, 'showMsgL');
                let colorRight = recogColor(faceRight, 'showMsgR');

                if (cube.updateCube(colorLeft, colorRight)) {
                    postResult();
                    return;
                }
                
                // schedule the next one. 
                // let delay = 1000/FPS - (Date.now() - begin);
                let fps = (1000/(Date.now() - begin)).toFixed(2);
                tips.innerHTML = "Recognizing in " + fps.toString() + "FPS...";

                setTimeout(processVideo, 0); 
            } catch (err) {
                utils.printError(err);
            };
        }

        function drawPoly(src, dst) {
            try {
                dst = src.clone();

                let color = new cv.Scalar(0, 0, 255, 255);

                cv.line(dst, pointA, pointB, color);
                cv.line(dst, pointB, pointD, color);
                cv.line(dst, pointC, pointD, color);
                cv.line(dst, pointC, pointA, color);
                cv.line(dst, pointC, pointE, color);
                cv.line(dst, pointE, pointF, color);
                cv.line(dst, pointF, pointD, color);

                let rect = new cv.Rect(30, 10, 250, 220);


                // draw grab rect
                let point1 = new cv.Point(rect.x, rect.y);
                let point2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);
                cv.rectangle(dst, point1, point2, color);

                cv.imshow('recogInput', dst);

            } catch (err) {
                utils.printError(err);
            };
        }

        function splitColor(src, dst) {
            try {
                let R, G, B;
                let split_thre = 80;

                for (row = 0; row < src.rows; row++) {
                    for (col = 0; col < src.cols; col++) {
                        let src_pixel = src.ucharPtr(row, col);
                        R = src_pixel[0];
                        G = src_pixel[1];
                        B = src_pixel[2];
                        A = src_pixel[3];

                        if (Math.abs(R-G) > split_thre || Math.abs(R-B) > split_thre || Math.abs(B-G) > split_thre || (R>160 && G>160 && B>160 && Math.abs(B-G)<50 && Math.abs(R-G)<50 && Math.abs(B-R)<50)) {
                            let tar_pixel = dst.ucharPtr(row, col);
                            tar_pixel[0] = R;
                            tar_pixel[1] = G;
                            tar_pixel[2] = B;
                            tar_pixel[3] = A;
                        }
                        else {
                            let tar_pixel = dst.ucharPtr(row, col);
                            tar_pixel[0] = 0;
                            tar_pixel[1] = 0;
                            tar_pixel[2] = 0;
                            tar_pixel[3] = 255;
                        }
                    }
                }
                cv.imshow('recogOutput', dst);
            } catch (err) {
                utils.printError(err);
            };
        }

        function foreExtraction(src, dst) {
            try {
                let gray = new cv.Mat();
                let opening = new cv.Mat();
                let coinsBg = new cv.Mat();
                // let coinsFg = new cv.Mat();
                let distTrans = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                cv.threshold(gray, gray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
                let M = cv.Mat.ones(3, 3, cv.CV_8U);
                cv.erode(gray, gray, M);
                cv.dilate(gray, opening, M);
                cv.dilate(opening, coinsBg, M, new cv.Point(-1, -1), 3);
                cv.distanceTransform(opening, distTrans, cv.DIST_L2, 5);
                cv.normalize(distTrans, distTrans, 1, 0, cv.NORM_INF);

                // get foreground
                cv.threshold(distTrans, dst, 0.7 * 1, 255, cv.THRESH_BINARY);

                gray.delete();
                opening.delete();
                coinsBg.delete();
                // coinsFg.delete();
                distTrans.delete();
                M.delete();

            } catch (err) {
                utils.printError(err);
            };
        }

        function grabCut(src, dst) {
            try {
                cv.cvtColor(src, dst, cv.COLOR_RGBA2RGB, 0);
                let mask = new cv.Mat();
                let bgdModel = new cv.Mat();
                let fgdModel = new cv.Mat();
                let rect = new cv.Rect(30, 10, 250, 220);
                cv.grabCut(dst, mask, rect, bgdModel, fgdModel, 3, cv.GC_INIT_WITH_RECT);
                // draw foreground
                for (let i = 0; i < dst.rows; i++) {
                    for (let j = 0; j < dst.cols; j++) {
                        if (mask.ucharPtr(i, j)[0] == 0 || mask.ucharPtr(i, j)[0] == 2) {
                            dst.ucharPtr(i, j)[0] = 0;
                            dst.ucharPtr(i, j)[1] = 0;
                            dst.ucharPtr(i, j)[2] = 0;
                        }
                    }
                }

                cv.imshow('recogOutput', dst);
            } catch (err) {
                utils.printError(err);
            };
        }

        function perspTransform(src, dst_l, dst_r, dsp_l, dsp_r) {
            try{
                let dsize = new cv.Size(240, 240);
            
                let srcTri_l = cv.matFromArray(4, 1, cv.CV_32FC2, [pointA.x, pointA.y, pointC.x, pointC.y, pointB.x, pointB.y, pointD.x, pointD.y]);
                let srcTri_r = cv.matFromArray(4, 1, cv.CV_32FC2, [pointC.x, pointC.y, pointE.x, pointE.y, pointD.x, pointD.y, pointF.x, pointF.y]);
                let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, 240, 0, 0, 240, 240, 240]);
                
                let M_l = cv.getPerspectiveTransform(srcTri_l, dstTri);
                cv.warpPerspective(src, dst_l, M_l, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                
                let M_r = cv.getPerspectiveTransform(srcTri_r, dstTri);
                cv.warpPerspective(src, dst_r, M_r, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

                dsp_l = dst_l;
                dsp_r = dst_r;

                let rect_x = 10;
                let rect_y = 10;

                let centers_x = [0+240/3/2, 240/3+240/3/2, 240*2/3+240/3/2];
                let centers_y = [0+240/3/2, 240/3+240/3/2, 240*2/3+240/3/2];

                for (let center_x_idx=0; center_x_idx<centers_x.length; center_x_idx++) {
                    let center_x = centers_x[center_x_idx];
                    for (let center_y_idx=0; center_y_idx<centers_y.length; center_y_idx++) {
                        let center_y = centers_y[center_y_idx];
                        // draw detect area rect
                        let color = new cv.Scalar(0, 0, 0);
                        let point1 = new cv.Point(center_x-rect_x, center_y-rect_y);
                        let point2 = new cv.Point(center_x+rect_x, center_y+rect_y);
                        cv.rectangle(dsp_l, point1, point2, color);
                        cv.rectangle(dsp_r, point1, point2, color);
                    }
                }

                cv.imshow('recogFaceLeft', dsp_l);
                cv.imshow('recogFaceRight', dsp_r);
            } catch (err) {
                utils.printError(err);
            };
        }

        function recogColor(src, showMsg='showMsgL') {
            try {
                let rows = src.rows;
                let cols = src.cols;

                let blockcolor = [];
                let classifier = Object.create(ColorClassifier_HSV);

                let rect_x = 10;
                let rect_y = 10;

                let centers_x = [0+rows/3/2, rows/3+rows/3/2, rows*2/3+rows/3/2];
                let centers_y = [0+cols/3/2, cols/3+cols/3/2, cols*2/3+cols/3/2];

                let src_hsv = new cv.Mat();
                cv.cvtColor(src, src_hsv, cv.COLOR_RGB2HSV);

                for (let center_x_idx=0; center_x_idx<centers_x.length; center_x_idx++) {
                    let linecolor = [];
                    let center_x = centers_x[center_x_idx];
                    for (let center_y_idx=0; center_y_idx<centers_y.length; center_y_idx++) {
                        let center_y = centers_y[center_y_idx];

                        let avg_H = 0, avg_S = 0, avg_V = 0;
                        for (let row=center_x-rect_x; row<center_x+rect_x; row++) {
                            for (let col=center_y-rect_y; col<center_y+rect_y; col++) {
                                let src_pixel = src_hsv.ucharPtr(row, col);
                                avg_H += src_pixel[0];
                                avg_S += src_pixel[1];
                                avg_V += src_pixel[2];
                            }
                        }
                        avg_H /= (2*rect_x)*(2*rect_y);
                        avg_S /= (2*rect_x)*(2*rect_y);
                        avg_V /= (2*rect_x)*(2*rect_y);

                        let c = classifier.classifyColor(avg_H, avg_S, avg_V);
                        
                        console.log(showMsg + "(" + center_x_idx.toString()+", "+center_y_idx.toString()+"): "+c+"("+avg_H.toString()+", "+avg_S.toString()+", "+avg_V.toString()+")")
                        
                        linecolor.push(c);
                    }
                    blockcolor.push(linecolor);
                }

                document.getElementById(showMsg).innerHTML = showMsg + ": " + blockcolor.toString();

                return blockcolor;
            } catch (err) {
                utils.printError(err);
            };
        }
        
        var ColorClassifier_RGB = {
            classifyColor: function(R, G, B) {
                if (this.isRed(R, G, B)) {
                    return 'R';
                }
                if (this.isGreen(R, G, B)) {
                    return 'G';
                }
                if (this.isBlue(R, G, B)) {
                    return 'B';
                }
                if (this.isOrange(R, G, B)) {
                    return 'O';
                }
                if (this.isYellow(R, G, B)) {
                    return 'Y';
                }
                if (this.isWhite(R, G, B)) {
                    return 'W';
                }
                return 'N';
            },
            isRed: function(R, G, B) {
                return R>G && R>B && B<150 && G<150 && Math.abs(G-B)<=30;
            },
            isGreen: function(R, G, B) {
                return G>R && G>B && R<100 && B<160;
            },
            isBlue: function(R, G, B) {
                return B>G && B>R && G<130 && R<130;
            },
            isOrange: function(R, G, B) {
                return R>150 && R>G && R>B && Math.abs(G-B)>30;
            },
            isYellow: function(R, G, B) {
                return R>150 && G>150 && B<150;
            },
            isWhite: function(R, G, B) {
                return (R>160 && G>160 && B>160 && Math.abs(B-G)<50 && Math.abs(R-G)<50 && Math.abs(B-R)<50) || (R<190 && R>120 && G>200 && B>200);
            }
        }

        var ColorClassifier_HSV = {
            classifyColor: function(H, S, V) {
                if (this.isRed(H, S, V)) {
                    return 'R';
                }
                if (this.isGreen(H, S, V)) {
                    return 'G';
                }
                if (this.isBlue(H, S, V)) {
                    return 'B';
                }
                if (this.isOrange(H, S, V)) {
                    return 'O';
                }
                if (this.isYellow(H, S, V)) {
                    return 'Y';
                }
                if (this.isWhite(H, S, V)) {
                    return 'W';
                }
                return 'N';
            },
            isRed: function(H, S, V) {
                return ((H>=0 && H<8) || (H>=156 && H<=180)) && S>=38 && S<=255 && V>=46 && V<=255;
            },
            isGreen: function(H, S, V) {
                return H>=40 && H<85 && S>=38 && S<=255 && V>=46 && V<=255;
            },
            isBlue: function(H, S, V) {
                return H>=85 && H<=124 && S>=38 && S<=255 && V>=46 && V<=255;
            },
            isOrange: function(H, S, V) {
                return H>=8 && H<20 && S>=38 && S<=255 && V>=46 && V<=255;
            },
            isYellow: function(H, S, V) {
                return H>=20 && H<40 && S>=38 && S<=255 && V>=46 && V<=255;
            },
            isWhite: function(H, S, V) {
                return H>=0 && H<=180 && S>=0 && S<=35 && V>=100 && V<=255;
            }
        }

        function blockChangeColor() {
            if (streaming) {
                return;
            }

            let ele = window.event.srcElement;
            let colors = ['W', 'Y', 'O', 'R', 'B', 'G'];
            let colorMap = {"N": "gray", "G": "#33CC33", "B": "#0000FF", "Y": "#FFFF1a", "R": "#E60000", "W": "#FFFFFF", "O": "#FF8000"};
            
            let color_idx = -1;
            if (ele.bgColor != 'N') {
                for (let i=0; i<6; i++) {
                    if (ele.bgColor == colorMap[colors[i]]) {
                        color_idx = i;
                        break;
                    }
                }
            }

            color_idx = (color_idx+1)%6;
            ele.bgColor = colorMap[colors[color_idx]];

            cube.initCube();
        }

        cube.initCube();

        // schedule the first one. 
        setTimeout(processVideo, 0);

    </script>
    <script type="text/javascript">
        let utils = new Utils('errorMessage');

        utils.loadCode('codeSnippet', 'codeEditor');

        let streaming = false;
        let videoInput = document.getElementById('videoInput');
        let startAndStop = document.getElementById('startAndStop');
        let reStart = document.getElementById('reStart');
        let done = document.getElementById('done');
        let test = document.getElementById('test');

        let recogInputEle = document.getElementById('recogInput');
        let recogInputContext = recogInputEle.getContext('2d');
        let recogOutputEle = document.getElementById('recogOutput');
        let recogOutputContext = recogOutputEle.getContext('2d');

        let recogFaceLeftEle = document.getElementById('recogFaceLeft');
        let recogFaceLeftContext = recogFaceLeftEle.getContext('2d');
        let recogFaceRightEle = document.getElementById('recogFaceRight');
        let recogFaceRightContext = recogFaceRightEle.getContext('2d');

        var Cube = {
            colors: ['W', 'Y', 'O', 'R', 'B', 'G'],
            colorMap: {"N": "gray", "G": "#33CC33", "B": "#0000FF", "Y": "#FFFF1a", "R": "#E60000", "W": "#FFFFFF", "O": "#FF8000"},
            transferMap: {
                "WBO": 9*0+0, "WB": 9*0+1, "WBR": 9*0+2, "WO": 9*0+3, "W": 9*0+4, "WR": 9*0+5, "WGO": 9*0+6, "WG": 9*0+7, "WGR": 9*0+8,
                "YGO": 9*1+0, "YG": 9*1+1, "YGR": 9*1+2, "YO": 9*1+3, "Y": 9*1+4, "YR": 9*1+5, "YBO": 9*1+6, "YB": 9*1+7, "YBR": 9*1+8,
                "OBW": 9*2+0, "OW": 9*2+1, "OGW": 9*2+2, "OB": 9*2+3, "O": 9*2+4, "OG": 9*2+5, "OBY": 9*2+6, "OY": 9*2+7, "OGY": 9*2+8,
                "RGW": 9*3+0, "RW": 9*3+1, "RBW": 9*3+2, "RG": 9*3+3, "R": 9*3+4, "RB": 9*3+5, "RGY": 9*3+6, "RY": 9*3+7, "RBY": 9*3+8,
                "BRW": 9*4+0, "BW": 9*4+1, "BOW": 9*4+2, "BR": 9*4+3, "B": 9*4+4, "BO": 9*4+5, "BRY": 9*4+6, "BY": 9*4+7, "BOY": 9*4+8,
                "GOW": 9*5+0, "GW": 9*5+1, "GRW": 9*5+2, "GO": 9*5+3, "G": 9*5+4, "GR": 9*5+5, "GOY": 9*5+6, "GY": 9*5+7, "GRY": 9*5+8,
            },
            cubestat: {},
            state: [],
            isFinish: false,

            initCube: function() {
                for (let c=0; c<6; c++) {
                    let color = this.colors[c];
                    let faceColor = this.synsFaceColor(color);
                    this.cubestat[color] = {"isComplete": this.judgeComplete(faceColor), "isUpdate": this.judgeUpdate(color, faceColor), "faceColor": faceColor};
                }
                this.displayCube();
                if (this.judgeFinish()) {
                    postResult();
                }
            },
            synsFaceColor: function(color) {
                let faceColor = [['N', 'N', 'N'], ['N', color, 'N'], ['N', 'N', 'N']];

                for (let row=0; row<3; row++) {
                    for (let col=0; col<3; col++) {
                        let idx = row*3+col;
                        let cell = document.getElementById(color+idx.toString());
                        switch (cell.bgColor) {
                            case "gray":
                                faceColor[row][col] = 'N';
                                break;
                            case "#33CC33":
                                faceColor[row][col] = 'G';
                                break;
                            case "#0000FF":
                                faceColor[row][col] = 'B';
                                break;
                            case "#FFFF1a":
                                faceColor[row][col] = 'Y';
                                break;
                            case "#E60000":
                                faceColor[row][col] = 'R';
                                break;
                            case "#FFFFFF":
                                faceColor[row][col] = 'W';
                                break;
                            case "#FF8000":
                                faceColor[row][col] = 'O';
                                break;
                            default:
                                break;
                        }
                    }
                }

                return faceColor;
            },
            updateCube: function(resultLeft, resultRight) {
                
                let center_left = resultLeft[1][1];
                let center_right = resultRight[1][1];

                // Cannot update if either center of the two faces is recognized
                if (center_left=='N' || center_right=='N') {
                    return;
                }

                if (!this.judgeComplete(resultLeft) || !this.judgeComplete(resultRight)) {
                    return;
                }

                // There must be something wrong when left==right
                if (center_left == center_right) {
                    return;
                }

                let lr = center_left+center_right;
                let adjustLeft, adjustRight;

                // console.log(lr);
                switch (lr) {
                    // G
                    case 'GY':
                        adjustLeft = this.rotateFaceClock(resultLeft);
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceClock(resultRight);
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'GR':
                        adjustLeft = resultLeft;
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = resultRight;
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'GW':
                        adjustLeft = this.rotateFaceReClock(resultLeft);
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceReClock(resultRight);
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'GO':
                        adjustLeft = this.rotateFaceClock(this.rotateFaceClock(resultLeft));
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceClock(this.rotateFaceClock(resultRight));
                        this.updateFace(center_right, adjustRight);
                        break;
                    // B
                    case 'BY':
                        adjustLeft = this.rotateFaceClock(resultLeft);
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceReClock(resultRight);
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'BR':
                        adjustLeft = this.rotateFaceClock(this.rotateFaceClock(resultLeft));
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceClock(this.rotateFaceClock(resultRight));
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'BW':
                        adjustLeft = this.rotateFaceReClock(resultLeft);
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceReClock(resultRight);
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'BO':
                        adjustLeft = resultLeft;
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = resultRight;
                        this.updateFace(center_right, adjustRight);
                        break;
                    // Y
                    case 'YB':
                        adjustLeft = this.rotateFaceClock(resultLeft);
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceReClock(resultRight);
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'YG':
                        adjustLeft = this.rotateFaceReClock(resultLeft);
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceReClock(resultRight);
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'YR':
                        adjustLeft = resultLeft;
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceReClock(resultRight);
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'YO':
                        adjustLeft = this.rotateFaceClock(this.rotateFaceClock(resultLeft));
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceReClock(resultRight);
                        this.updateFace(center_right, adjustRight);
                        break;
                    // R
                    case 'RB':
                        adjustLeft = resultLeft;
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = resultRight;
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'RG':
                        adjustLeft = this.rotateFaceClock(this.rotateFaceClock(resultLeft));
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceClock(this.rotateFaceClock(resultRight));
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'RY':
                        adjustLeft = this.rotateFaceClock(resultLeft);
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceClock(this.rotateFaceClock(resultRight));
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'RW':
                        adjustLeft = this.rotateFaceReClock(resultLeft);
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceClock(this.rotateFaceClock(resultRight));
                        this.updateFace(center_right, adjustRight);
                        break;
                    // W
                    case 'WB':
                        adjustLeft = this.rotateFaceClock(resultLeft);
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceClock(resultRight);
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'WG':
                        adjustLeft = this.rotateFaceClock(resultLeft);
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceClock(resultRight);
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'WR':
                        adjustLeft = resultLeft;
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceClock(resultRight);
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'WO':
                        adjustLeft = this.rotateFaceClock(this.rotateFaceClock(resultLeft));
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceClock(resultRight);
                        this.updateFace(center_right, adjustRight);
                        break;
                    // O
                    case 'OB':
                        adjustLeft = this.rotateFaceClock(this.rotateFaceClock(resultLeft));
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = this.rotateFaceClock(this.rotateFaceClock(resultRight));
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'OG':
                        adjustLeft = resultLeft;
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = resultRight;
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'OY':
                        adjustLeft = this.rotateFaceClock(resultLeft);
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = resultRight;
                        this.updateFace(center_right, adjustRight);
                        break;
                    case 'OW':
                        adjustLeft = this.rotateFaceReClock(resultLeft);
                        this.updateFace(center_left, adjustLeft);
                        adjustRight = resultRight;
                        this.updateFace(center_right, adjustRight);
                        break;
                    // other occations are impossible
                    default:
                        return;
                }

                this.displayCube();

                if (this.judgeFinish()) {
                    return true;
                }
                return false;
            },
            updateFace: function(color, result) {
                if (this.judgeUpdate(color, result)) {
                    this.cubestat[color]["faceColor"] = result;
                    this.cubestat[color]["isUpdate"] = true;
                    // complete when there no 'N' in the face
                    if (this.judgeComplete(result)) {
                        this.cubestat[color]["isComplete"] = true;
                    }
                }
            },
            judgeUpdate: function(color, result) {
                if (!this.cubestat.hasOwnProperty(color)) {
                    return true;
                }
                if (this.cubestat[color]["faceColor"] != result) {
                    return true;
                }
                return false;
            },
            judgeComplete: function(result) {
                for (let row=0; row<3; row++) {
                    for (let col=0; col<3; col++) {
                        if (result[row][col] == 'N') {
                            return false;
                        }
                    }
                }
                return true;
            },
            displayCube: function() {
                for (let c=0; c<6; c++) {
                    let color = this.colors[c];
                    let facestat = this.cubestat[color];
                    if (!facestat["isUpdate"]) {
                        continue;
                    }
                    this.cubestat[color]["isUpdate"] = false;
                    let faceColor = facestat["faceColor"];
                    for (let row=0; row<3; row++) {
                        for (let col=0; col<3; col++) {
                            let idx = row*3+col;
                            let cell = document.getElementById(color+idx.toString());
                            cell.bgColor = this.colorMap[faceColor[row][col]];
                        }
                    }
                }
            },
            rotateFaceClock: function(face) {
                let dd = [];
                for (let col=0; col<3; col++) {
                    let li = [];
                    for (let row=2; row>=0; row--) {
                        li.push(face[row][col]);
                    }
                    dd.push(li);
                }
                return dd;
            },
            rotateFaceReClock: function(face) {
                let dd = [];
                for (let col=2; col>=0; col--) {
                    let li = [];
                    for (let row=0; row<3; row++) {
                        li.push(face[row][col]);
                    }
                    dd.push(li);
                }
                return dd;
            },
            judgeFinish: function() {
                if (this.isFinish) {
                    done.removeAttribute('disabled');
                    return true;
                }

                for (let c=0; c<6; c++) {
                    color = this.colors[c];
                    if (this.cubestat[color]["isComplete"] == false) {
                        return false;
                    }
                }
                this.transferState();
                
                if (this.judgeValid()) {
                    done.removeAttribute('disabled');
                    this.isFinish = true;
                    return true;
                }
                done.disabled = true;
                return false;
            },
            judgeValid: function() {
                if (this.state.length != 54) {
                    return false;
                }
                let cubeset = new Set(this.state);
                if (cubeset.size != 54) {
                    return false;
                }
                return true;
            },
            compare: function(c1, c2) {
                if (c1 < c2) {
                    return c1+c2
                }
                return c2+c1
            },
            transferState: function() {
                this.state = []

                let faceCenter = 'W';
                let faceColor = this.cubestat[faceCenter]["faceColor"];
                this.state.push(this.transferMap[faceColor[0][0]+this.compare(this.cubestat['O']["faceColor"][0][0], this.cubestat['B']["faceColor"][0][2])]);
                this.state.push(this.transferMap[faceColor[0][1]+this.cubestat['B']["faceColor"][0][1]])
                this.state.push(this.transferMap[faceColor[0][2]+this.compare(this.cubestat['R']["faceColor"][0][2], this.cubestat['B']["faceColor"][0][0])]);
                this.state.push(this.transferMap[faceColor[1][0]+this.cubestat['O']["faceColor"][0][1]]);
                this.state.push(this.transferMap[faceColor[1][1]]);
                this.state.push(this.transferMap[faceColor[1][2]+this.cubestat['R']["faceColor"][0][1]]);
                this.state.push(this.transferMap[faceColor[2][0]+this.compare(this.cubestat['O']["faceColor"][0][2], this.cubestat['G']["faceColor"][0][0])]);
                this.state.push(this.transferMap[faceColor[2][1]+this.cubestat['G']["faceColor"][0][1]]);
                this.state.push(this.transferMap[faceColor[2][2]+this.compare(this.cubestat['R']["faceColor"][0][0], this.cubestat['G']["faceColor"][0][2])]);

                faceCenter = 'Y';
                faceColor = this.cubestat[faceCenter]["faceColor"];
                this.state.push(this.transferMap[faceColor[0][0]+this.compare(this.cubestat['O']["faceColor"][2][2], this.cubestat['G']["faceColor"][2][0])]);
                this.state.push(this.transferMap[faceColor[0][1]+this.cubestat['G']["faceColor"][2][1]])
                this.state.push(this.transferMap[faceColor[0][2]+this.compare(this.cubestat['R']["faceColor"][2][0], this.cubestat['G']["faceColor"][2][2])]);
                this.state.push(this.transferMap[faceColor[1][0]+this.cubestat['O']["faceColor"][2][1]]);
                this.state.push(this.transferMap[faceColor[1][1]]);
                this.state.push(this.transferMap[faceColor[1][2]+this.cubestat['R']["faceColor"][2][1]]);
                this.state.push(this.transferMap[faceColor[2][0]+this.compare(this.cubestat['O']["faceColor"][2][0], this.cubestat['B']["faceColor"][2][2])]);
                this.state.push(this.transferMap[faceColor[2][1]+this.cubestat['B']["faceColor"][2][1]]);
                this.state.push(this.transferMap[faceColor[2][2]+this.compare(this.cubestat['R']["faceColor"][2][2], this.cubestat['B']["faceColor"][2][0])]);

                faceCenter = 'O';
                faceColor = this.cubestat[faceCenter]["faceColor"];
                this.state.push(this.transferMap[faceColor[0][0]+this.compare(this.cubestat['W']["faceColor"][0][0], this.cubestat['B']["faceColor"][0][2])]);
                this.state.push(this.transferMap[faceColor[0][1]+this.cubestat['W']["faceColor"][1][0]])
                this.state.push(this.transferMap[faceColor[0][2]+this.compare(this.cubestat['W']["faceColor"][2][0], this.cubestat['G']["faceColor"][0][0])]);
                this.state.push(this.transferMap[faceColor[1][0]+this.cubestat['B']["faceColor"][1][2]]);
                this.state.push(this.transferMap[faceColor[1][1]]);
                this.state.push(this.transferMap[faceColor[1][2]+this.cubestat['G']["faceColor"][1][0]]);
                this.state.push(this.transferMap[faceColor[2][0]+this.compare(this.cubestat['B']["faceColor"][2][2], this.cubestat['Y']["faceColor"][2][0])]);
                this.state.push(this.transferMap[faceColor[2][1]+this.cubestat['Y']["faceColor"][1][0]]);
                this.state.push(this.transferMap[faceColor[2][2]+this.compare(this.cubestat['G']["faceColor"][2][0], this.cubestat['Y']["faceColor"][0][0])]);
                
                faceCenter = 'R';
                faceColor = this.cubestat[faceCenter]["faceColor"];
                this.state.push(this.transferMap[faceColor[0][0]+this.compare(this.cubestat['G']["faceColor"][0][2], this.cubestat['W']["faceColor"][2][2])]);
                this.state.push(this.transferMap[faceColor[0][1]+this.cubestat['W']["faceColor"][1][2]])
                this.state.push(this.transferMap[faceColor[0][2]+this.compare(this.cubestat['W']["faceColor"][0][2], this.cubestat['B']["faceColor"][0][0])]);
                this.state.push(this.transferMap[faceColor[1][0]+this.cubestat['G']["faceColor"][1][2]]);
                this.state.push(this.transferMap[faceColor[1][1]]);
                this.state.push(this.transferMap[faceColor[1][2]+this.cubestat['B']["faceColor"][1][0]]);
                this.state.push(this.transferMap[faceColor[2][0]+this.compare(this.cubestat['G']["faceColor"][2][2], this.cubestat['Y']["faceColor"][0][2])]);
                this.state.push(this.transferMap[faceColor[2][1]+this.cubestat['Y']["faceColor"][1][2]]);
                this.state.push(this.transferMap[faceColor[2][2]+this.compare(this.cubestat['B']["faceColor"][2][0], this.cubestat['Y']["faceColor"][2][2])]);
                
                faceCenter = 'B';
                faceColor = this.cubestat[faceCenter]["faceColor"];
                this.state.push(this.transferMap[faceColor[2][2]+this.compare(this.cubestat['O']["faceColor"][2][0], this.cubestat['Y']["faceColor"][2][0])]);
                this.state.push(this.transferMap[faceColor[2][1]+this.cubestat['Y']["faceColor"][2][1]]);
                this.state.push(this.transferMap[faceColor[2][0]+this.compare(this.cubestat['R']["faceColor"][2][2], this.cubestat['Y']["faceColor"][2][2])]);
                this.state.push(this.transferMap[faceColor[1][2]+this.cubestat['O']["faceColor"][1][0]]);
                this.state.push(this.transferMap[faceColor[1][1]]);
                this.state.push(this.transferMap[faceColor[1][0]+this.cubestat['R']["faceColor"][1][2]]);
                this.state.push(this.transferMap[faceColor[0][2]+this.compare(this.cubestat['W']["faceColor"][0][0], this.cubestat['O']["faceColor"][0][0])]);
                this.state.push(this.transferMap[faceColor[0][1]+this.cubestat['W']["faceColor"][0][1]]);
                this.state.push(this.transferMap[faceColor[0][0]+this.compare(this.cubestat['W']["faceColor"][0][2], this.cubestat['R']["faceColor"][0][2])]);

                faceCenter = 'G';
                faceColor = this.cubestat[faceCenter]["faceColor"];
                this.state.push(this.transferMap[faceColor[0][0]+this.compare(this.cubestat['W']["faceColor"][2][0], this.cubestat['O']["faceColor"][0][2])]);
                this.state.push(this.transferMap[faceColor[0][1]+this.cubestat['W']["faceColor"][2][1]])
                this.state.push(this.transferMap[faceColor[0][2]+this.compare(this.cubestat['W']["faceColor"][2][2], this.cubestat['R']["faceColor"][0][0])]);
                this.state.push(this.transferMap[faceColor[1][0]+this.cubestat['O']["faceColor"][1][2]]);
                this.state.push(this.transferMap[faceColor[1][1]]);
                this.state.push(this.transferMap[faceColor[1][2]+this.cubestat['R']["faceColor"][1][0]]);
                this.state.push(this.transferMap[faceColor[2][0]+this.compare(this.cubestat['O']["faceColor"][2][2], this.cubestat['Y']["faceColor"][0][0])]);
                this.state.push(this.transferMap[faceColor[2][1]+this.cubestat['Y']["faceColor"][0][1]]);
                this.state.push(this.transferMap[faceColor[2][2]+this.compare(this.cubestat['R']["faceColor"][2][0], this.cubestat['Y']["faceColor"][0][2])]);

            }
        };

        let cube = Object.create(Cube);

        reStart.addEventListener('click', () => {
            let colors = ['W', 'Y', 'O', 'R', 'B', 'G'];
            let colorMap = {"N": "gray", "G": "#33CC33", "B": "#0000FF", "Y": "#FFFF1a", "R": "#E60000", "W": "#FFFFFF", "O": "#FF8000"};

            for (let i=0; i<6; i++) {
                let color = colors[i];
                let faceColor = [['N', 'N', 'N'], ['N', color, 'N'], ['N', 'N', 'N']];

                for (let row=0; row<3; row++) {
                    for (let col=0; col<3; col++) {
                        let idx = row*3+col;
                        let cell = document.getElementById(color+idx.toString());
                        cell.bgColor = colorMap[faceColor[row][col]];
                    }
                }
            }
            cube.initCube();
        });

        startAndStop.addEventListener('click', () => {
            if(!streaming) {
                utils.clearError();
                utils.startCamera('qvga', onVideoStarted, 'videoInput');
            } else {
                utils.stopCamera();
                onVideoStopped();
            }
        });

        done.addEventListener('click', () => {
            if (cube.isFinish){
                postResult();
            }
            else {
                this.disabled = true;
            }
        });

        test.addEventListener('click', () => {
            let faces = [   [['Y', 'W', 'O'], ['G', 'W', 'O'], ['W', 'O', 'R']],
                            [['O', 'W', 'R'], ['W', 'Y', 'G'], ['W', 'Y', 'R']],
                            [['B', 'Y', 'R'], ['Y', 'O', 'G'], ['O', 'R', 'G']],
                            [['B', 'B', 'W'], ['W', 'R', 'R'], ['W', 'R', 'Y']],
                            [['B', 'G', 'O'], ['B', 'B', 'R'], ['G', 'B', 'G']],
                            [['B', 'Y', 'Y'], ['O', 'G', 'B'], ['Y', 'O', 'G']]
                        ];

            let colors = ['W', 'Y', 'O', 'R', 'B', 'G'];
            let colorMap = {"N": "gray", "G": "#33CC33", "B": "#0000FF", "Y": "#FFFF1a", "R": "#E60000", "W": "#FFFFFF", "O": "#FF8000"};

            for (let i=0; i<6; i++) {
                let color = colors[i];
                let faceColor = faces[i];

                for (let row=0; row<3; row++) {
                    for (let col=0; col<3; col++) {
                        let idx = row*3+col;
                        let cell = document.getElementById(color+idx.toString());
                        cell.bgColor = colorMap[faceColor[row][col]];
                    }
                }
            }
            cube.initCube();
        })
        
        function postResult() {
            location.replace("/2?state=[" + cube.state.toString() + "]");
            // $.ajax({
            //     url: '/2',
            //     data: JSON.stringify({"state": cube.state}),
            //     type: 'POST',
            //     dataType: 'json',
            //     success: function(response) {
            //         console.log(response);
            //         // window.opener=null;
            //         // window.top.open('','_self','');
            //         // window.close(this);
            //         window.location.href="2";
            //     },
            //     error: function(error) {
            //         utils.printError(error);
            //     },
            // });
        }

        function onVideoStarted() {
            streaming = true;
            startAndStop.innerText = 'Stop';
            reStart.disabled = true;
            videoInput.width = videoInput.videoWidth;
            videoInput.height = videoInput.videoHeight;
            utils.executeCode('codeEditor');
        }

        function onVideoStopped() {
            streaming = false;

            recogInputContext.clearRect(0, 0, recogInputEle.width, recogInputEle.height);
            recogOutputContext.clearRect(0, 0, recogOutputEle.width, recogOutputEle.height);
            recogFaceLeftContext.clearRect(0, 0, recogFaceLeftEle.width, recogFaceLeftEle.height);
            recogFaceRightContext.clearRect(0, 0, recogFaceRightEle.width, recogFaceRightEle.height);

            startAndStop.innerText = 'Start';
            reStart.removeAttribute('disabled');
        }

        utils.loadOpenCv(() => {
            startAndStop.removeAttribute('disabled');
        });
    </script>
    <script src="https://ajax.aspnetcdn.com/ajax/jquery/jquery-3.5.1.min.js"></script>
</html>